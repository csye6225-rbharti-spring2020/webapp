package com.rohan.cloudProject.service;

import com.rohan.cloudProject.model.User;
import com.rohan.cloudProject.repository.UserRepository;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.*;

import static org.mockito.Mockito.when;

/**
 * Test class for the Service Layer functions.
 *
 * @author rohan_bharti
 */
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserServiceTest {

    @InjectMocks
    @Autowired
    private UserService userService;

    @Mock
    private UserRepository mockUserRepository;

    @Before
    public void init() {
        MockitoAnnotations.initMocks(this);
    }

    /**
     * Checks if the new user with a duplicate Email is rejected or not.
     *
     * @throws IllegalArgumentException
     */
    @Test(expected = IllegalArgumentException.class)
    public void addNewUserWithDuplicateEmailTest() {
        User dummyUser = new User();
        dummyUser.setFirstName("Rohan");
        dummyUser.setLastName("Bharti");
        dummyUser.setEmail("rohan@xyz.com");
        dummyUser.setPassword("Qwertyuiop1234@");
        userService.createNewUser(dummyUser);

        List<User> dummyList = new ArrayList<>();
        dummyList.add(dummyUser);
        when(mockUserRepository.findAll()).thenReturn(dummyList);

        User toBeSavedUser = new User("Joe", "Doe", "rohan@xyz.com", "Abcdert1234#");
        userService.createNewUser(toBeSavedUser);
    }

    /**
     * Test to check if the account created and account updated values supplied by the user get persisted or not.
     * These values are supposed to be auto generated by the Application itself.
     */
    @Test
    public void checkForFieldsCreationTest() {
        User toBeSavedUser = new User("Joe", "Doe", "rohan@xyz.com", "Abcdert1234#");
        toBeSavedUser.setAccountCreated(new Date(2000, 11, 21));
        toBeSavedUser.setAccountUpdated(new Date(2000, 11, 21));

        User savedUser = userService.createNewUser(toBeSavedUser);

        Assert.assertNotEquals(savedUser.getAccountCreated(), toBeSavedUser.getAccountCreated());
        Assert.assertNotEquals(savedUser.getAccountUpdated(), toBeSavedUser.getAccountUpdated());
    }

    /**
     * Test to ensure "bad" passwords aren't stored. All passwords must have a minimum length of 8 characters, one lowercase, one Uppercase,
     * one SpecialCharacter and no WhiteSpaces
     */
    @Test
    public void validatePasswordStoringRules() {
        List<String> weakPasswords = Arrays.asList("Rohan2", "ROhan2497", "abcd", "   ", "ROHAN24@", "Kndno243LK", "QWERT1234@", "password1234");

        for (String password : weakPasswords) {
            Assert.assertFalse(userService.checkPasswordValidity(password));
        }
    }

    /**
     * Test to ensure that the password is encrypted before storing it into the database.
     */
    @Test
    public void checkPasswordHashing() {
        User dummyUser = new User();
        dummyUser.setFirstName("Rohan");
        dummyUser.setLastName("Bharti");
        dummyUser.setEmail("rohan@xyz.com");
        dummyUser.setPassword("Qwertyuiop1234@");

        User userSaved = userService.createNewUser(dummyUser);

        Assert.assertNotEquals(userSaved.getPassword(), dummyUser.getPassword());
    }

    /**
     * Test to ensure if a NON-EMAIL username cannot be stored into the database
     */
    @Test(expected = IllegalArgumentException.class)
    public void checkNonEmailAsUsername() {
        User dummyUser = new User();
        dummyUser.setFirstName("Rohan");
        dummyUser.setLastName("Bharti");
        dummyUser.setEmail("rohan_bharti");
        dummyUser.setPassword("Qwertyuiop1234@");

        userService.createNewUser(dummyUser);
    }

    /**
     * Test to ensure successful Update User functionality
     */
    @Test
    public void testSuccessfulUserUpdate() {
        Map<String, Object> fieldsToBeUpdated = new HashMap<>();
        fieldsToBeUpdated.put("first_name", "Ranbir");
        fieldsToBeUpdated.put("last_name", "Kapoor");
        fieldsToBeUpdated.put("password", "Qwertyuiop1234@");

        User dummyUser = new User();
        dummyUser.setFirstName("Rohan");
        dummyUser.setLastName("Bharti");
        dummyUser.setEmail("rohan_bharti@xyz.com");
        dummyUser.setPassword(encryptPassword("Qwertyuiop1234@"));

        when(mockUserRepository.findById("1")).thenReturn(Optional.of(dummyUser));

        User updatedUser = userService.updateUser(fieldsToBeUpdated, "1");

        Assert.assertEquals(updatedUser.getFirstName(), fieldsToBeUpdated.get("first_name"));
        Assert.assertEquals(updatedUser.getLastName(), fieldsToBeUpdated.get("last_name"));
    }

    /**
     * Test to ensure that the user cannot update email_address or Id or Account Updated or Account Created
     */
    @Test(expected = IllegalArgumentException.class)
    public void testUpdateUserRestrictions() {
        Map<String, Object> fieldsToBeUpdated = new HashMap<>();
        fieldsToBeUpdated.put("email_address", "rohan.bharti@nuance.com");

        User dummyUser = new User();
        dummyUser.setFirstName("Rohan");
        dummyUser.setLastName("Bharti");
        dummyUser.setEmail("rohan_bharti");
        dummyUser.setPassword("Qwertyuiop1234@");

        when(mockUserRepository.findById("1")).thenReturn(Optional.of(dummyUser));

        User updatedUser = userService.updateUser(fieldsToBeUpdated, "1");
    }

    /**
     * Helper Method. Takes in the plain password and encrypts it using BCryptPasswordEncoder with BCrypt Salt.
     *
     * @param plainPassword
     * @return encryptedPassword
     */
    private String encryptPassword(String plainPassword) {
        String strongSalt = BCrypt.gensalt(10);
        String encryptedPassword = BCrypt.hashpw(plainPassword, strongSalt);
        return encryptedPassword;
    }

}
